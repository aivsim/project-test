function printHeader() {
    return (
        `/*
    This file was generated by the tool. Do not modify it by hand.
    To generate this file, use \`npm run gen-api\` command.
*/
// tslint:disable
import * as moment from 'moment';
import * as queryString from 'query-string';
import apiClient from './apiClient';
// import * as model from '../model';
// import * as m from './model';
import { Option } from 'varis-ui';
`
    );
}

function ident(n) {
    return ' '.repeat(n * 4);
}

function getApiResponseType(name) {
    return name[0].toUpperCase() + name.substr(1) + 'ApiResponse';
}

function printType(type, isNullable) {
    const flags = (t, n, a) => `${a ? '(' : ''}${t}${n && !a ? ' | null' : ''}${a ? ')[]' : ''}`;
    if (type.tsType) {
        return flags(type.tsType, type.null, type.array);
    }

    switch (type.type) {
        case 'string':
            return flags('string', type.null || isNullable, type.array);
        case 'number':
            return flags('number', type.null || isNullable, type.array);
        case 'bool':
            return flags('boolean', type.null || isNullable, type.array);
        case 'date':
            return flags('moment.Moment', type.null || isNullable, type.array);
        case 'enum':
            return flags(`${type.enum.join(' | ')}`, type.null || isNullable, type.array);
        case 'object':
            return flags(`{ ${Object.keys(type.props).map(name => `${name}: ${printType(type.props[name])}`).join(', ')} }`, type.null || isNullable, type.array);
        default:
            throw new Error(`Unsupported type ${type.type}`);
    }
}

function getNameValue(value) {
    return value.replace('?', '');
}

function isPropertyNullable(name) {
    return name.endsWith('?');
}

function printParams(operation) {
    const { request: { props }, http: { method, url, params } } = operation;
    if (Object.keys(props).length === 0) {
        return '';
    }

    let result = params
        .map(name => ({ name: getNameValue(name), type: props[getNameValue(name)], isNullable: isPropertyNullable(name) }))
        .map(x => `${x.name}: ${printType(x.type, x.isNullable)}`);

    const remainingKeys = Object.keys(props).filter(x => !params.includes(x) && !params.includes(x + '?'));
    if (remainingKeys.length === 1) {
        const lastKey = remainingKeys[0];
        result.push(`${lastKey}: ${printType(props[lastKey])}`);
    } else if (remainingKeys.length > 0) {
        const request = {
            ...operation.request,
            null: false,
            props: remainingKeys.reduce((o, k) => Object.assign(o, { [k]: props[k] }), {})
        };
        result.push(`data: ${printType(request)}`);
    }

    return result.join(', ');
}

function printResponse(operation) {
    if (operation.response === null) {
        return 'any';
    }

    return printType(operation.response);
}

function printMap(path, level, response) {
    if (response.array) {
        const innerMap = printMap('s', level, { ...response, array: false });
        return `${path} && ${path}.map((s: any) => ${innerMap})`;
    }

    switch (response.type) {
        case 'string':
        case 'number':
        case 'bool':
        case 'enum':
            return path;
        case 'date':
            return `${response.null ? `${path} && ` : ''}moment.utc(${path})`;
        case 'time':
            return `${response.null ? `${path} && ` : ''}moment.utc('0000-00-00T' + ${path})`;
        case 'object':
            const sp = ident(level + 1);
            return `${path} && {\n${Object.keys(response.props).map(p => `${sp}    ${p}: ${printMap(path + '.' + p, level + 1, response.props[p])}`).join(',\n')}\n${sp}}`;
        default:
            throw new Error(`Unsupported type ${response.type}`);
    }
}

function printMappings(operation) {
    const innerMap = printMap('x', 1, operation.response);
    if (innerMap == null) {
        return '';
    }

    return `.then(x => (${innerMap}))`;
}

function printOperation(controller, operation) {
    const { request: { props }, http: { method, url, params } } = operation;
    let result = `${method.toLowerCase()}(`;
    result += '`/' + controller.route;
    if (url != null && url.length > 0) {
        result += '/' + url.replace(/{/gi, '${').replace('?', '');
    }

    const remainingKeys = Object.keys(props || {}).filter(x => !params.includes(x) && !params.includes(x + '?'));
    if (['GET', 'DELETE'].includes(method)) {
        if (remainingKeys.length === 1) {
            result += '?${queryString.stringify({ ' + remainingKeys[0] + ' })}';
        } else if (remainingKeys.length > 0) {
            result += '?${queryString.stringify({ ' + remainingKeys.map(key => `${key}: ${parseByType(props, key)}`).join(', ') + ' })}';
        }
    }

    result += '`';
    if (['POST', 'PUT'].includes(method)) {
        if (Object.keys(props || {}).length === 1) {
            result += `, { ${Object.keys(props || {})[0]} }`;
        } else {
            result += ', data';
        }
    }

    result += ')';

    return result;
}

function parseByType(props, key) {
    switch (props[key].type) {
        case 'date':
            return `data.${key}${props[key].type === 'date' ? ` ? moment(data.${key}).utc().toJSON() : null` : ``}`;
        default:
            return `data.${key}`;
    }
}

function printAction(controller, controllerName, name) {
    const action = controller.methods[name];
    return `${ident(1)}${name}(${printParams(action)}): Promise<${controllerName}.${getApiResponseType(name)}> {\n${ident(2)}return apiClient.${printOperation(controller, action)}${printMappings(action)};\n${ident(1)}}`;
}

function printActions(controller, name) {
    return Object.keys(controller.methods)
        .map(x => printAction(controller, name, x))
        .join(',\n');
}

function printResponseType(controller, name) {
    const action = controller.methods[name];
    return `${ident(1)}export type ${getApiResponseType(name)} = ${printResponse(action)}`;
}

function printResponseTypes(controller, name) {
    const types = Object.keys(controller.methods)
        .map(x => printResponseType(controller, x))
        .join('\n');
    return `export declare module ${name} {\n${types}\n}`;
}

function printController(controller, name) {
    const responseTypes = printResponseTypes(controller, name);
    return `${responseTypes}\nexport const ${name} = {\n${printActions(controller, name)}\n};`
}

module.exports = function (controllers) {
    let content = printHeader();
    content += '\n';
    content += Object.keys(controllers)
        .sort()
        .map(x => printController(controllers[x], x))
        .join('\n\n');

    return content + '\n';
}